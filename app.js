function formatTimeRemaining(expiryDate) { if (!expiryDate) return 'N/A'; const expiry = new Date(expiryDate); const now = new Date(); const diff = expiry - now; if (diff <= 0) return 'Expired'; const hours = Math.floor(diff / 3600000); const minutes = Math.floor((diff % 3600000) / 60000); return `${hours}h ${minutes}m`; }
function formatBigNumber(num) { if (num==null)return"0";const t=typeof num=="bigint"?num:BigInt(num);if(t<1000000)return t.toLocaleString("en-US");const o=["","K","M","B","T","q","Q","s","S","o","n","d","ud","dd","td","qd","Qd","sd","Sd","od","nd"],e=Math.floor((t.toString().length-1)/3);if(e>=o.length)return t.toExponential(2);const r=BigInt("1"+"0".repeat(3*e)),a=parseFloat(t/r);let l;return l=a>=100?a.toFixed(1):a>=10?a.toFixed(2):a.toFixed(2),l.replace(/\.0+$/,"")+o[e]}
document.addEventListener('DOMContentLoaded', () => {
    const loginContainer = document.getElementById('login-container'); const mainAppContainer = document.getElementById('main-app'); const loginError = document.getElementById('login-error-message'); const userNameEl = document.getElementById('user-name'); const homeUserNameEl = document.getElementById('home-username'); const userAvatarEl = document.getElementById('user-avatar'); const userStatusBadgeEl = document.getElementById('user-status-badge'); const navLinks = document.querySelectorAll('.nav-link'); const pages = document.querySelectorAll('.page'); const userProfileToggle = document.getElementById('user-profile-toggle'); const dropdownMenu = document.getElementById('dropdown-menu'); const manageKeysLink = document.getElementById('manage-keys-link'); const suggestionForm = document.getElementById('suggestion-form'); const removeExpiredBtn = document.getElementById('remove-expired-btn'); let currentUser = null; let allUsers = [];
    const MAX_PRESTIGE_LEVEL = 50; const BASE_COST_PER_HOUR = 1000000000n; // 1 Billion
    const KING_GAME_UPGRADES_CONFIG = { click: { name: 'Royal Scepter', baseCost: 15, costMultiplier: 1.15, value: 1, description: 'Increases coins per click.' }, b1: { name: 'Peasant Hut', baseCost: 100, costMultiplier: 1.1, cps: 1, description: 'Generates 1 coin/sec.' }, b2: { name: 'Farm', baseCost: 1100, costMultiplier: 1.12, cps: 8, description: 'Generates 8 coins/sec.' }, b3: { name: 'Bakery', baseCost: 8500, costMultiplier: 1.13, cps: 35, description: 'Generates 35 coins/sec.' }, b4: { name: 'Blacksmith', baseCost: 40000, costMultiplier: 1.13, cps: 150, description: 'Generates 150 coins/sec.' }, b5: { name: 'Market', baseCost: 210000, costMultiplier: 1.14, cps: 720, description: 'Generates 720 coins/sec.' }, b6: { name: 'Inn', baseCost: 1.4e6, costMultiplier: 1.15, cps: 3800, description: 'Generates 3.8K coins/sec.' }, b7: { name: 'Guard Tower', baseCost: 9e6, costMultiplier: 1.15, cps: 21000, description: 'Generates 21K coins/sec.' }, b8: { name: 'Church', baseCost: 5.5e7, costMultiplier: 1.16, cps: 115000, description: 'Generates 115K coins/sec.' }, b9: { name: 'Library', baseCost: 3.8e8, costMultiplier: 1.16, cps: 650000, description: 'Generates 650K coins/sec.' }, b10: { name: 'Town Hall', baseCost: 2.5e9, costMultiplier: 1.17, cps: 3.4e6, description: 'Generates 3.4M coins/sec.' }, b11: { name: 'Castle', baseCost: 1.8e10, costMultiplier: 1.18, cps: 2e7, description: 'Generates 20M coins/sec.' }, b12: { name: 'Barracks', baseCost: 1.2e11, costMultiplier: 1.18, cps: 1.1e8, description: 'Generates 110M coins/sec.' }, b13: { name: 'University', baseCost: 8e11, costMultiplier: 1.19, cps: 6e8, description: 'Generates 600M coins/sec.' }, b14: { name: 'Cathedral', baseCost: 5.2e12, costMultiplier: 1.19, cps: 3.5e9, description: 'Generates 3.5B coins/sec.' }, b15: { name: 'Royal Palace', baseCost: 3.6e13, costMultiplier: 1.2, cps: 2.2e10, description: 'Generates 22B coins/sec.' }, b16: { name: 'Kingdom', baseCost: 2.8e14, costMultiplier: 1.21, cps: 1.5e11, description: 'Generates 150B coins/sec.' }, b17: { name: 'Empire', baseCost: 2.1e15, costMultiplier: 1.21, cps: 9e11, description: 'Generates 900B coins/sec.' }, b18: { name: 'Senate', baseCost: 1.5e16, costMultiplier: 1.22, cps: 5.5e12, description: 'Generates 5.5T coins/sec.' }, b19: { name: 'Colosseum', baseCost: 1.1e17, costMultiplier: 1.22, cps: 3e13, description: 'Generates 30T coins/sec.' }, b20: { name: 'Grand Temple', baseCost: 8e17, costMultiplier: 1.23, cps: 1.8e14, description: 'Generates 180T coins/sec.' } };
    const highTierNames = [ 'Quantum Forge', 'Nebula Reactor', 'Stargate Hub', 'Galactic Exchange', 'Celestial Spire', 'Ethereal Nexus', 'Singularity Core', 'Hyperspace Beacon', 'Chrono-Synth Factory', 'Void Matter Extractor', 'Cosmic Oracle', 'Stellar Shipyard', 'Dimension Weaver', 'Reality Engine', 'Genesis Chamber', 'Omega Citadel', 'Astro-Observatory', 'Dark Matter Plant', 'Supernova Catalyst', 'Infinity Gate', 'Celestial Forge', 'Stardust Silo', 'Event Horizon Lab', 'Galaxy Brain Nexus', 'Time Dilation Spire', 'Reality Bender', 'The Omniverse', 'Finality Point', 'The Great Attractor', 'The Void' ];
    let lastCpsClient = BigInt('180000000000000'); let lastCostClient = BigInt('800000000000000000');
    for (let i = 21; i <= 50; i++) { const cpsMultiplier = BigInt(Math.round((5 + i * 0.1) * 10)); const costMultiplier = BigInt(Math.round((6 + i * 0.15) * 100)); lastCpsClient = (lastCpsClient * cpsMultiplier) / 10n; lastCostClient = (lastCostClient * costMultiplier) / 100n; const name = highTierNames[i - 21] || `Cosmic Entity #${i - 20}`; KING_GAME_UPGRADES_CONFIG[`b${i}`] = { name: name, baseCost: lastCostClient, costMultiplier: 1.23 + (i * 0.002), cps: lastCpsClient, description: `Generates ${formatBigNumber(lastCpsClient)} coins/sec.` };}
    const TROOPS_CONFIG = { 'warrior': { name: 'Warrior', cost: 10000, power: 10, costMultiplier: 1.05 }, 'archer': { name: 'Archer', cost: 50000, power: 45, costMultiplier: 1.06 }, 'knight': { name: 'Knight', cost: 250000, power: 220, costMultiplier: 1.07 }, 'mage': { name: 'Mage', cost: 1200000, power: 1100, costMultiplier: 1.08 }, 'dragon': { name: 'Dragon', cost: 8000000, power: 6500, costMultiplier: 1.1 },};
    const SPECIAL_UNITS_CONFIG = { 'elite_soldier': { name: 'Elite Soldier', cost: 5000000, power: 3000, costMultiplier: 1.12 }, 'queens_guard': { name: 'Queen\'s Guard', cost: 25000000, power: 12000, costMultiplier: 1.15 }, 'royal_guard': { name: 'Royal Guard', cost: 100000000, power: 50000, costMultiplier: 1.2 },};
    const ALL_TROOPS_CONFIG = { ...TROOPS_CONFIG, ...SPECIAL_UNITS_CONFIG };
    const DEFENSES_CONFIG = { 'wall': { name: 'Wooden Wall', cost: 15000, power: 15, costMultiplier: 1.05 }, 'tower': { name: 'Watchtower', cost: 70000, power: 60, costMultiplier: 1.06 }, 'fortress': { name: 'Fortress', cost: 350000, power: 280, costMultiplier: 1.07 }, 'cannon': { name: 'Cannon', cost: 1800000, power: 1500, costMultiplier: 1.08 }, 'magic_shield': { name: 'Magic Shield', cost: 10000000, power: 8000, costMultiplier: 1.1 },};
    const GEM_BOOSTS_CONFIG = { 'x2_coins': { name: '2x Coin Boost (1h)', cost: 10 }, 'half_cost': { name: '50% Upgrade Discount (5m)', cost: 5 },};
    let kingGameState = { coins: 0n, upgrades: {}, cps: 0n, clickValue: 1n, prestige_level: 0, gems: 0, troops: {}, defenses: {}, power: '0', rank: 'Unranked', title: null, userRoles: {}, totalBonus: 1.0, active_boosts: {}, isRewardAvailable: false, unreadAttackCount: 0, has_active_key: false, time_purchase_count: 0, rebirth_progress: {} };
    let kingGameInterval = null; let kingGameSyncInterval = null; let leaderboardInterval = null;
    const setupMobileNav = () => { const mainNav = document.querySelector('.top-bar-left nav'); const mobileNavContainer = document.getElementById('mobile-nav-links'); if (!mainNav || !mobileNavContainer || !dropdownMenu) return; mobileNavContainer.innerHTML = ''; mainNav.querySelectorAll('a').forEach(link => { const clone = link.cloneNode(true); clone.addEventListener('click', (e) => { if (clone.dataset.page) { e.preventDefault(); window.history.pushState({ page: clone.dataset.page }, '', `/${clone.dataset.page === 'home' ? '' : clone.dataset.page}`); switchPage(clone.dataset.page); } dropdownMenu.classList.remove('show'); }); mobileNavContainer.appendChild(clone); }); };
    const checkUserStatus = async () => { try { const response = await fetch('/api/user'); if (response.status === 401) { showLoginView(); return; } if (response.status === 403) { showLoginView('You must join the Discord server.', 'https://discord.gg/RhDnUQr4Du'); return; } if (!response.ok) throw new Error('Failed to fetch user data'); const user = await response.json(); currentUser = user; setupMainApp(user); } catch (error) { console.error(error); showLoginView('An error occurred. Please try again later.'); } };
    const showLoginView = (message = null, discordLink = null) => { loginContainer.classList.remove('hidden'); mainAppContainer.classList.add('hidden'); if (loginError) { loginError.textContent = message; const parent = loginError.closest('.card-box'); let existingBtn = document.getElementById('discord-join-btn'); if(existingBtn) existingBtn.remove(); if (message && discordLink) { const joinBtn = document.createElement('a'); joinBtn.id = 'discord-join-btn'; joinBtn.href = discordLink; joinBtn.target = '_blank'; joinBtn.className = 'discord-btn'; joinBtn.style.marginTop = '15px'; joinBtn.textContent = 'Click to join the Discord'; parent.appendChild(joinBtn); } } };
    const setupMainApp = (user) => { loginContainer.classList.add('hidden'); mainAppContainer.classList.remove('hidden'); userNameEl.textContent = user.discord_username; if (homeUserNameEl) homeUserNameEl.textContent = user.discord_username; userAvatarEl.src = user.discord_avatar || 'assets/logo.png'; const displayStatus = user.isAdmin ? 'Admin' : user.user_status; userStatusBadgeEl.textContent = displayStatus; userStatusBadgeEl.className = 'status-badge ' + displayStatus.toLowerCase(); if (user.isAdmin) { manageKeysLink.classList.remove('hidden'); } handleRouting(); };
    const switchPage = (pageId) => { if (kingGameInterval) clearInterval(kingGameInterval); if (kingGameSyncInterval) clearInterval(kingGameSyncInterval); pages.forEach(page => page.classList.toggle('hidden', page.id !== `page-${pageId}`)); navLinks.forEach(link => link.classList.toggle('active', link.dataset.page === pageId)); if (pageId === 'get-key') renderGetKeyPage(); if (pageId === 'manage-keys' && currentUser && currentUser.isAdmin) renderAdminPanel(); if (pageId === 'earn-time') renderEarnTimePage(); };
    const handleRouting = () => { const path = window.location.pathname.replace(/\/$/, ""); let pageId = 'home'; if (path === '/get-key') pageId = 'get-key'; if (path === '/suggestion') pageId = 'suggestion'; if (path === '/manage-keys') pageId = 'manage-keys'; if (path === '/earn-time') pageId = 'earn-time'; if (pageId === 'home' && path !== '' && path !== '/') { window.history.replaceState({page: pageId}, '', '/'); } switchPage(pageId); };
    const renderGetKeyPage = async () => { const container = document.getElementById('key-generation-content'); if (!container || !currentUser) return; container.innerHTML = `<p>Checking for an existing key...</p>`; try { const response = await fetch('/api/generate-key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) }); const data = await response.json(); if (response.ok) { displayKey(data); return; } const urlParams = new URLSearchParams(window.location.search); const hash = urlParams.get('hash'); if (hash) { container.innerHTML = ` <p>Thank you! You can now get your key.</p> <button id="generate-key-btn" class="discord-btn">Get Key</button> <div id="key-display-area" class="hidden"></div> <div id="generate-error" class="error-message" style="margin-top: 8px;"></div> `; document.getElementById('generate-key-btn').addEventListener('click', () => handleGenerateKey(hash)); } else { container.innerHTML = ` <p>To get your 12-hour key, please complete the task below.</p> <a href="https://link-hub.net/1409420/j5AokQm937Cf" class="discord-btn">Start Task</a> <p class="text-muted" style="margin-top: 1rem; font-size: 14px;">After completing the task, you will be redirected back here to claim your key.</p> `; } } catch (error) { console.error(error); container.innerHTML = `<p class="error-message">${error.message}</p>`; } };
    const handleGenerateKey = async (hash = null) => { const btn = document.getElementById('generate-key-btn'); if (btn) { btn.disabled = true; btn.textContent = 'Generating...'; } const errorEl = document.getElementById('generate-error'); if (errorEl) errorEl.textContent = ''; try { const response = await fetch('/api/generate-key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(hash ? { hash } : {}) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Could not generate key.'); displayKey(data); } catch (error) { if (errorEl) errorEl.textContent = error.message; if (btn) { btn.disabled = false; btn.textContent = 'Get Key'; } } };
    const displayKey = (data) => { const container = document.getElementById('key-generation-content'); if (!container) return; container.innerHTML = ` <div id="key-display-area"> <h4>Your key is ready:</h4> <div class="key-container"> <input type="text" value="${data.key}" readonly id="generated-key-input" /> <button id="copy-key-btn" class="secondary-btn">Copy</button> </div> <button id="get-script-btn" class="discord-btn">Get Script</button> <button id="reset-hwid-btn" class="secondary-btn">Reset HWID (24h Cooldown)</button> <div id="hwid-status" class="status-message"></div> ${data.type === 'temp' ? `<p>Expires in: <strong>${formatTimeRemaining(data.expires)}</strong></p>` : ''} </div> `; document.getElementById('copy-key-btn').addEventListener('click', () => { const input = document.getElementById('generated-key-input'); const btn = document.getElementById('copy-key-btn'); input.select(); document.execCommand('copy'); btn.textContent = 'Copied!'; setTimeout(() => { btn.textContent = 'Copy'; }, 2000); }); document.getElementById('get-script-btn').addEventListener('click', (e) => { const scriptToCopy = 'loadstring(game:HttpGet("https://raw.githubusercontent.com/DoggyKing/king-gen-hub/refs/heads/main/keyhub",true))()'; const btn = e.target; navigator.clipboard.writeText(scriptToCopy).then(() => { btn.textContent = 'Copied!'; btn.style.backgroundColor = 'var(--brand-green)'; setTimeout(() => { btn.textContent = 'Get Script'; btn.style.backgroundColor = 'var(--brand-blue)'; }, 2000); }).catch(err => { console.error('Failed to copy script: ', err); btn.textContent = 'Error'; btn.style.backgroundColor = 'var(--brand-red)'; setTimeout(() => { btn.textContent = 'Get Script'; btn.style.backgroundColor = 'var(--brand-blue)'; }, 2000); }); }); document.getElementById('reset-hwid-btn').addEventListener('click', handleResetHwid); };
    const handleResetHwid = async () => { const btn = document.getElementById('reset-hwid-btn'); const statusEl = document.getElementById('hwid-status'); if (!btn || !statusEl) return; btn.disabled = true; statusEl.textContent = 'Resetting...'; try { const response = await fetch('/api/reset-hwid', { method: 'POST' }); const result = await response.json(); if (!response.ok) throw new Error(result.error); statusEl.className = 'status-message success'; statusEl.textContent = result.message; } catch (error) { statusEl.className = 'status-message error'; statusEl.textContent = error.message || 'Failed to reset HWID.'; } finally { setTimeout(() => { btn.disabled = false; }, 2000); } };
    const renderAdminPanel = async () => { const container = document.getElementById('admin-key-list'); const searchInput = document.getElementById('admin-search-input'); if (!container || !searchInput) return; container.innerHTML = '<p>Loading keys...</p>'; try { const response = await fetch('/api/admin/keys'); if (!response.ok) throw new Error('Failed to fetch keys.'); const keys = await response.json(); container.innerHTML = `<div class="admin-table-container"><table class="admin-table"><thead><tr><th>Key</th><th>Type</th><th>Owner</th><th>HWID (Roblox ID)</th><th>Expires In</th><th>Action</th></tr></thead><tbody>${keys.length === 0 ? '<tr><td colspan="6" style="text-align: center;">No keys found.</td></tr>' : keys.map(key => ` <tr data-key-id="${key.id}" data-key-type="${key.key_type}" data-expires-at="${key.expires_at || ''}"> <td class="key-value">${key.key_value}</td> <td><span class="key-badge ${key.key_type}">${key.key_type}</span></td> <td class="owner-name">${key.discord_username || 'N/A'}</td> <td class="hwid-cell editable">${key.roblox_user_id || 'Not Set'}</td> <td class="expires-cell editable">${key.key_type === 'temp' ? formatTimeRemaining(key.expires_at) : 'N/A'}</td> <td class="actions-cell"><button class="delete-key-btn secondary-btn-red">Delete</button></td> </tr>`).join('')}</tbody></table></div>`; const tableRows = container.querySelectorAll('tbody tr'); searchInput.oninput = () => { const searchTerm = searchInput.value.toLowerCase(); tableRows.forEach(row => { const keyValue = row.querySelector('.key-value').textContent.toLowerCase(); const ownerName = row.querySelector('.owner-name').textContent.toLowerCase(); row.style.display = (keyValue.includes(searchTerm) || ownerName.includes(searchTerm)) ? '' : 'none'; }); }; container.querySelectorAll('.delete-key-btn').forEach(btn => btn.addEventListener('click', handleDeleteKey)); container.querySelectorAll('.hwid-cell.editable').forEach(cell => cell.addEventListener('click', handleEdit)); container.querySelectorAll('.expires-cell.editable').forEach(cell => cell.addEventListener('click', handleEdit)); } catch (error) { container.innerHTML = `<p class="error-message">${error.message}</p>`; } };
    const handleRemoveAllExpired = async () => { if (!confirm('Are you sure you want to delete ALL expired keys? This action cannot be undone.')) return; removeExpiredBtn.disabled = true; removeExpiredBtn.textContent = 'Deleting...'; try { const response = await fetch('/api/admin/keys', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'delete_expired' }) }); const result = await response.json(); if (!response.ok) throw new Error(result.error || 'Failed to delete expired keys.'); alert(result.message); renderAdminPanel(); } catch (error) { alert('Error: ' + error.message); } finally { removeExpiredBtn.disabled = false; removeExpiredBtn.textContent = 'Remove All Expired'; } };
    const handleDeleteKey = async (e) => { const row = e.target.closest('tr'); const keyId = row.dataset.keyId; if (confirm('Are you sure you want to delete this key permanently?')) { try { const response = await fetch('/api/admin/keys', { method: 'DELETE', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key_id: keyId }) }); if (!response.ok) throw new Error('Failed to delete.'); row.remove(); } catch (error) { alert('Error deleting key.'); } } };
    const handleEdit = async (e) => { const cell = e.target; const row = cell.closest('tr'); const keyId = row.dataset.keyId; const keyType = row.dataset.keyType; const isHwid = cell.classList.contains('hwid-cell'); const isExpires = cell.classList.contains('expires-cell'); if (isExpires && keyType.toLowerCase() !== 'temp') { alert("Only 'temp' keys can have their expiration date modified."); return; } let newHwid = undefined; let newExpiresAt = undefined; if (isHwid) { const currentHwid = cell.textContent.trim() === 'Not Set' ? '' : cell.textContent.trim(); const result = prompt('Enter the new Roblox User ID (leave blank to clear HWID):', currentHwid); if (result === null) return; newHwid = result.trim(); } else if (isExpires) { const result = prompt('Enter the time to ADD to the key (e.g., "24h" for 24 hours, "90m" for 90 minutes, or "clear" to remove expiry):', '12h'); if (result === null) return; const input = result.trim().toLowerCase(); if (input === 'clear') { newExpiresAt = null; } else { const parseDuration = (str) => { const matchHours = str.match(/(\d+)h/); const matchMinutes = str.match(/(\d+)m/); let ms = 0; if (matchHours) ms += parseInt(matchHours[1]) * 3600000; if (matchMinutes) ms += parseInt(matchMinutes[1]) * 60000; return ms; }; const durationMs = parseDuration(input); if (durationMs > 0) { newExpiresAt = new Date(Date.now() + durationMs).toISOString(); } else { alert('Invalid format. Use "24h", "90m", or "clear".'); return; } } } if (newHwid === undefined && newExpiresAt === undefined) return; try { cell.classList.add('loading'); const payload = { key_id: keyId }; if (newHwid !== undefined) payload.new_roblox_user_id = newHwid; if (newExpiresAt !== undefined) payload.new_expires_at = newExpiresAt; const response = await fetch('/api/admin/keys', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) throw new Error('Failed to update.'); if (newHwid !== undefined) { cell.textContent = newHwid === '' ? 'Not Set' : newHwid; } if (newExpiresAt !== undefined) { const finalExpires = newExpiresAt === null ? '' : newExpiresAt; row.dataset.expiresAt = finalExpires; cell.textContent = finalExpires === '' ? 'N/A' : formatTimeRemaining(finalExpires); } cell.classList.remove('loading'); cell.classList.add('success-flash'); setTimeout(() => cell.classList.remove('success-flash'), 1000); } catch (error) { alert('Error updating key: ' + error.message); cell.classList.remove('loading'); } };
    const renderLeaderboardModal = () => {
        const modal = document.getElementById('leaderboard-modal'); const container = document.getElementById('leaderboard-container'); const controls = document.getElementById('leaderboard-controls'); if (!modal || !container || !controls) return;
        let currentSortBy = 'power';
        const fetchAndDisplay = async (sortBy) => {
            currentSortBy = sortBy; 
            if(modal.classList.contains('hidden')) return;
            try {
                const response = await fetch('/api/earn-time', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action: 'get_leaderboard', sortBy }) });
                if (!response.ok) throw new Error('Failed to fetch leaderboard data.');
                const data = await response.json();
                controls.querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.sort === sortBy));
                if (data.players.length === 0) { container.innerHTML = '<p>No players to display.</p>'; return; }
                container.innerHTML = `<div class="leaderboard-table-container"><table class="leaderboard-table"><thead><tr><th>#</th><th>Player</th><th>Power</th><th>Coins</th><th>Rebirth</th></tr></thead><tbody>${data.players.map((p, index) => {
                    let title = ''; let titleClass = `rank-${sortBy}`;
                    if (p.isEmperor) { title = '‚öúÔ∏è Emperor'; titleClass = 'rank-emperor'; } else { const top3 = data.tops[sortBy] || []; const rankIndex = top3.indexOf(p.discord_id); if (rankIndex !== -1) { if (rankIndex === 0) title = 'üëë King'; else if (rankIndex === 1) title = '‚≠ê Queen'; else if (rankIndex === 2) title = '‚öîÔ∏è General'; } }
                    return `<tr><td>${index + 1}</td><td class="leaderboard-name-cell">${p.discord_username} ${title ? `<span class="rank-title ${titleClass}">${title}</span>` : ''}</td><td>${formatBigNumber(p.power)}</td><td>${formatBigNumber(p.king_game_coins)}</td><td>${p.prestige_level}</td></tr>`
                }).join('')}</tbody></table></div>`;
            } catch (error) { container.innerHTML = `<p class="error-message">${error.message}</p>`; }
        };
        controls.querySelectorAll('button').forEach(button => { button.onclick = () => fetchAndDisplay(button.dataset.sort); });
        modal.classList.remove('hidden'); fetchAndDisplay(currentSortBy); if (leaderboardInterval) clearInterval(leaderboardInterval); leaderboardInterval = setInterval(() => fetchAndDisplay(currentSortBy), 15000);
    };
    const renderHistoryModal = async () => {
        const modal = document.getElementById('history-modal'); const container = document.getElementById('history-container'); if (!modal || !container || !currentUser) return; container.innerHTML = '<p>Loading your combat history...</p>'; modal.classList.remove('hidden');
        try {
            const response = await fetch('/api/earn-time?action=get_attack_history'); const history = await response.json(); if (!response.ok) throw new Error(history.error || 'Could not load history.'); if (history.length === 0) { container.innerHTML = '<p>You have no combat history yet.</p>'; return; }
            const formatLosses = (losses) => { if (!losses || Object.keys(losses).length === 0) return '<li>No losses</li>'; return Object.entries(losses).map(([unit, count]) => `<li>${count.toLocaleString('en-US')} ${ALL_TROOPS_CONFIG[unit]?.name || DEFENSES_CONFIG[unit]?.name || unit}</li>`).join(''); };
            container.innerHTML = history.map(log => {
                const userWasAttacker = String(log.attacker_id) === String(currentUser.discord_id); const stolenAmount = BigInt(log.coins_stolen);
                if (userWasAttacker) {
                    const victory = log.attacker_wins; return ` <div class="history-log-item ${victory ? 'victory' : 'defeat'}"> <div class="history-log-header"> <h5>ATTACK on ${log.defender_name || 'Unknown'} (${victory ? 'VICTORY' : 'DEFEAT'})</h5> <small>${new Date(log.timestamp).toLocaleString()}</small> </div> <p>${victory ? `You attacked and stole <strong>${formatBigNumber(stolenAmount)}</strong> coins.` : `Your attack was repelled.`}</p> <div class="history-log-details"> <div class="losses-section"><h6>Your Losses</h6><ul>${formatLosses(log.attacker_losses)}</ul></div> <div class="losses-section"><h6>Enemy's Losses</h6><ul>${formatLosses(log.defender_losses)}</ul></div> </div> </div>`;
                } else {
                    const victory = !log.attacker_wins; return ` <div class="history-log-item ${victory ? 'victory' : 'defeat'}"> <div class="history-log-header"> <h5>DEFENSE against ${log.attacker_name || 'Unknown'} (${victory ? 'VICTORY' : 'DEFEAT'})</h5> <small>${new Date(log.timestamp).toLocaleString()}</small> </div> <p>${victory ? `You successfully defended your empire!` : `${log.attacker_name} stole <strong>${formatBigNumber(stolenAmount)}</strong> coins from you.`}</p> <div class="history-log-details"> <div class="losses-section"><h6>Your Losses</h6><ul>${formatLosses(log.defender_losses)}</ul></div> <div class="losses-section"><h6>Attacker's Losses</h6><ul>${formatLosses(log.attacker_losses)}</ul></div> </div> <button class="secondary-btn revenge-btn" data-log-id="${log.id}" ${log.revenge_used ? 'disabled' : ''}> ${log.revenge_used ? 'Revenge Used' : 'Revenge'} </button> </div>`;
                }
            }).join('');
            container.querySelectorAll('.revenge-btn:not(:disabled)').forEach(btn => { btn.addEventListener('click', () => { if (confirm('Are you sure you want to use your one-time revenge on this player? This will not have a cooldown.')) { handleKingGameAction('revenge_attack', { logId: btn.dataset.logId }); modal.classList.add('hidden'); } }); });
        } catch (error) { container.innerHTML = `<p class="error-message">${error.message}</p>`; }
    };
    const getCost = (baseCost, costMultiplier, level, userRoles) => { let finalCost = BigInt(Math.ceil(Number(baseCost) * Math.pow(costMultiplier, level))); if (userRoles.coins === 'General') { finalCost = finalCost * 90n / 100n; } return finalCost;};
    const getUpgradeCost=(u,c)=>{const t=KING_GAME_UPGRADES_CONFIG[u];let o=getCost(BigInt(t.baseCost),t.costMultiplier,c,kingGameState.userRoles);return kingGameState.active_boosts.half_cost&&new Date(kingGameState.active_boosts.half_cost)>new Date&&(o/=2n),o};
    const getUnitCost=(u,c,i)=>{const t=i?ALL_TROOPS_CONFIG[u]:DEFENSES_CONFIG[u];return getCost(BigInt(t.cost),t.costMultiplier,c,kingGameState.userRoles)};
    const handleKingGameAction = async (action, params = {}) => { try { const response = await fetch('/api/earn-time', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ action, ...params }) }); const data = await response.json(); if (!response.ok) throw new Error(data.error || 'Game action failed.'); kingGameState = { ...kingGameState, ...data, coins: BigInt(data.coins), cps: BigInt(data.cps), clickValue: BigInt(data.clickValue), power: BigInt(data.power) }; if (data.unreadAttackCount !== undefined) { kingGameState.unreadAttackCount = data.unreadAttackCount; const ping = document.getElementById('history-ping'); if (ping) { if (kingGameState.unreadAttackCount > 0) { ping.textContent = kingGameState.unreadAttackCount; ping.classList.remove('hidden'); } else { ping.classList.add('hidden'); } } } if (data.message) alert(data.message); if (data.notifications && Array.isArray(data.notifications)) { data.notifications.forEach(notification => alert(notification)); } if (data.battleReport) alert(data.battleReport); if (action === 'prestige') alert(`Congratulations on your Rebirth (Level ${kingGameState.prestige_level})! Your journey starts anew with powerful bonuses.`); if (action === 'buy_boost') alert(`Boost purchased successfully!`); if (action === 'send_coins') { alert("Coins sent successfully!"); document.getElementById('kg-send-amount').value = ''; document.getElementById('send-fee-info').textContent = ''; document.getElementById('kg-recipient-search').value = ''; } if (action === 'buy_time' && data.newExpiresAt) { const hours = params.hours || 1; alert(`Successfully added ${hours} hour(s) to your key! It now expires on: ${new Date(data.newExpiresAt).toLocaleString()}`); if(!document.getElementById('page-get-key').classList.contains('hidden')) renderGetKeyPage(); } updateKingGameUI(); } catch (error) { alert(`Error: ${error.message}`); } };
    const updateKingGameUI = () => { if (!document.getElementById('king-game-container')) return; document.getElementById('kg-coin-count').textContent = formatBigNumber(kingGameState.coins); document.getElementById('kg-cps-count').textContent = `${formatBigNumber(kingGameState.cps)} coins/sec`; document.getElementById('kg-player-power').textContent = formatBigNumber(kingGameState.power); const titleEl = document.getElementById('kg-player-title'); const rankEl = document.getElementById('kg-player-rank'); const bonusEl = document.getElementById('kg-player-total-bonus'); if (kingGameState.title) { titleEl.textContent = kingGameState.title === 'Emperor' ? '‚öúÔ∏è Emperor' : kingGameState.title; titleEl.parentElement.classList.remove('hidden'); rankEl.textContent = kingGameState.rank; } else { titleEl.parentElement.classList.add('hidden'); rankEl.textContent = kingGameState.rank; } bonusEl.textContent = `x${kingGameState.totalBonus.toLocaleString("en-US", {minimumFractionDigits: 1, maximumFractionDigits: 2})}`; document.getElementById('kg-gem-count').textContent = `${kingGameState.gems || 0} Gems`; const pausedOverlay = document.getElementById('kg-paused-overlay'); if (kingGameState.has_active_key) { if (pausedOverlay) pausedOverlay.classList.add('hidden'); } else { if (pausedOverlay) pausedOverlay.classList.remove('hidden'); } const claimBtn = document.getElementById('claim-reward-btn'); if (claimBtn) claimBtn.classList.toggle('hidden', !kingGameState.isRewardAvailable);
        const renderList=(c,t,e,n)=>{c.innerHTML="";for(const i in t){if(n&&SPECIAL_UNITS_CONFIG[i]){const l=["King","Queen","General"];let s=!1;switch(i){case"royal_guard":s="King"===kingGameState.userRoles.power;break;case"queens_guard":s="Queen"===kingGameState.userRoles.power;break;case"elite_soldier":s=l.includes(kingGameState.userRoles.power)}if(!s)continue}const d=t[i];let a,g,p;e?(a=kingGameState.upgrades[i]||0,g=getUpgradeCost(i,a)):(p=(n?kingGameState.troops:kingGameState.defenses)[i]?.quantity||0,g=getUnitCost(i,p,n));const f=document.createElement("div");f.className="upgrade-item",f.innerHTML=` <div class="upgrade-info"> <strong>${d.name} ${e?`(Lvl ${a})`:`(x${p})`}</strong> <small class="desc">${e?d.description:`Power: ${d.power.toLocaleString("en-US")}`}</small> <small>Cost: ${formatBigNumber(g)}</small> </div> <div class="button-group" style="display: flex; gap: 5px;"> <button class="secondary-btn max-btn" data-id="${i}" ${kingGameState.coins<g?"disabled":""}>Max</button> <button class="secondary-btn buy-btn" data-id="${i}" ${kingGameState.coins<g?"disabled":""}>Buy</button> </div> `,f.querySelector(".buy-btn").addEventListener("click",t=>{const a=t.target.dataset.id;if(e)handleKingGameAction("buy_upgrade",{upgradeId:a});else{const g=t.shiftKey?100:t.ctrlKey?10:1;handleKingGameAction(n?"buy_troop":"buy_defense",{unitId:a,quantity:g})}}),f.querySelector(".max-btn").addEventListener("click",()=>{const a=f.querySelector(".max-btn").dataset.id;e?handleKingGameAction("buy_upgrade",{upgradeId:a,quantity:"max"}):handleKingGameAction(n?"buy_troop":"buy_defense",{unitId:a,quantity:"max"})}),c.appendChild(f)}};
        renderList(document.getElementById('kg-upgrades-list'), KING_GAME_UPGRADES_CONFIG, true, false); renderList(document.getElementById('kg-army-list'), ALL_TROOPS_CONFIG, false, true); renderList(document.getElementById('kg-defenses-list'), DEFENSES_CONFIG, false, false); const gemShopContainer=document.getElementById("kg-gem-shop");gemShopContainer.innerHTML="";for(const id in GEM_BOOSTS_CONFIG){const config=GEM_BOOSTS_CONFIG[id],isActive=kingGameState.active_boosts[id]&&new Date(kingGameState.active_boosts[id])>new Date(),btn=document.createElement("button");btn.className="secondary-btn",btn.textContent=`${config.name} (${config.cost} Gems)`,btn.disabled=isActive||kingGameState.gems<config.cost,btn.addEventListener("click",()=>handleKingGameAction("buy_boost",{boostId:id})),gemShopContainer.appendChild(btn)}
        const progress = kingGameState.rebirth_progress; const rebirthContainer = document.getElementById('rebirth-button-container'); const progressBar = document.getElementById('rebirth-progress-bar'); const progressText = document.getElementById('rebirth-progress-text'); if (progress && rebirthContainer && progressBar && progressText) { if (progress.canRebirth) { rebirthContainer.innerHTML = `<button id="kg-rebirth-btn" class="discord-btn">Rebirth (Level ${kingGameState.prestige_level + 1})</button>`; rebirthContainer.querySelector('#kg-rebirth-btn').addEventListener('click', () => { if (confirm('Are you sure you want to Rebirth? This will reset your coins, buildings, army, defenses, and key time costs for a powerful x1.5 coin bonus and +2 Gems! Your leaderboard stats will also be reset.')) handleKingGameAction('prestige'); }); progressBar.style.width = '100%'; progressBar.style.backgroundColor = 'var(--brand-green)'; progressText.textContent = `Ready to Rebirth!`; } else if(kingGameState.prestige_level >= MAX_PRESTIGE_LEVEL) { rebirthContainer.innerHTML = `<p class="max-prestige-msg">You have reached the max Rebirth level!</p>`; progressBar.style.width = '100%'; progressText.textContent = `Max Level`; } else { rebirthContainer.innerHTML = `<p class="text-muted">Reach Lvl ${progress.requiredLevel} on ${progress.requiredPercent}% of buildings to Rebirth.</p>`; const displayPercent = Math.min(100, Math.floor((progress.currentPercent / progress.requiredPercent) * 100)); progressBar.style.width = `${displayPercent}%`; progressBar.style.backgroundColor = 'var(--brand-blue)'; progressText.textContent = `Progress: ${progress.currentPercent}% / ${progress.requiredPercent}%`; } }
    };
    const fetchUserList = async () => { try { const response = await fetch('/api/earn-time?action=get_users'); allUsers = await response.json(); } catch(e) { console.error("Failed to fetch user list", e); } };
    const setupUserSearch = (inputId, dropdownId, onSelect, contentGenerator, userList) => { const searchInput = document.getElementById(inputId); const dropdown = document.getElementById(dropdownId); if (!searchInput || !dropdown) return; let selectedUserId = null; let highlightedIndex = -1; const updateHighlight = () => { dropdown.querySelectorAll('a').forEach((item, index) => item.classList.toggle('highlighted', index === highlightedIndex)); }; const updateDropdown = () => { const query = searchInput.value.toLowerCase(); const sourceList = userList || allUsers; const filteredUsers = sourceList.filter(u => u.discord_username.toLowerCase().startsWith(query) && u.discord_id !== currentUser.discord_id); dropdown.innerHTML = ''; highlightedIndex = -1; if (filteredUsers.length > 0) { filteredUsers.slice(0, 5).forEach(user => { const item = document.createElement('a'); item.innerHTML = contentGenerator(user); item.addEventListener("mousedown", () => { searchInput.value = user.discord_username; selectedUserId = user.discord_id; dropdown.style.display = 'none'; onSelect(selectedUserId, searchInput); }); dropdown.appendChild(item); }); updateHighlight(); dropdown.style.display = 'block'; } else { dropdown.style.display = 'none'; } }; searchInput.addEventListener('input', updateDropdown); searchInput.addEventListener('keyup', updateDropdown); searchInput.addEventListener('focus', updateDropdown); searchInput.addEventListener('blur', () => setTimeout(() => dropdown.style.display = 'none', 200)); searchInput.addEventListener('keydown', (e) => { const items = dropdown.querySelectorAll('a'); if (items.length === 0) return; if (e.key === 'ArrowDown') { e.preventDefault(); highlightedIndex = (highlightedIndex + 1) % items.length; updateHighlight(); } else if (e.key === 'ArrowUp') { e.preventDefault(); highlightedIndex = (highlightedIndex - 1 + items.length) % items.length; updateHighlight(); } else if (e.key === 'Enter' || e.key === 'Tab') { if (highlightedIndex !== -1) { e.preventDefault(); items[highlightedIndex].dispatchEvent(new MouseEvent('mousedown')); } } }); };
    const openGiftingModal = async () => { const modal = document.getElementById('gifting-modal'); const dropdown = document.getElementById('gift-recipient-dropdown'); dropdown.innerHTML = '<li>Loading players...</li>'; modal.classList.remove('hidden'); try { const response = await fetch('/api/earn-time?action=get_giftable_users'); if (!response.ok) throw new Error('Could not load player list.'); const giftableUsers = await response.json(); let giftRecipientId = null; const setGiftRecipient = (id) => { giftRecipientId = id; document.getElementById('gift-reward-btn').disabled = !id; }; setupUserSearch( 'gift-recipient-search', 'gift-recipient-dropdown', setGiftRecipient, user => `<span class="username">${user.discord_username}</span><span class="key-time">üïí ${formatTimeRemaining(user.expires_at)}</span>`, giftableUsers ); document.getElementById('gift-reward-btn').onclick = () => { if (giftRecipientId) { handleKingGameAction('claim_daily_reward', { recipientId: giftRecipientId }); modal.classList.add('hidden'); document.getElementById('gift-recipient-search').value = ''; giftRecipientId = null; } else { alert('Please select a player to gift the reward to.'); } }; } catch (error) { dropdown.innerHTML = `<li>${error.message}</li>`; } };
    const renderKingGame = async () => {
        await fetchUserList();
        const container = document.getElementById('earn-time-content'); 
        container.innerHTML = ` <style>.progress-bar-container{width:100%;background-color:var(--background-primary);border-radius:var(--border-radius);overflow:hidden;margin:10px 0}.progress-bar{height:20px;line-height:20px;text-align:center;color:white;font-weight:bold;transition:width .3s ease-in-out}.rebirth-info{text-align:center;margin-top:10px}</style> <div id="king-game-container" class="king-game-layout"> <div id="kg-paused-overlay" class="hidden"><h3>Game Paused</h3><p>You need an active key to play. Your progress is saved.</p><a href="/get-key" class="discord-btn">Get a Key</a></div> <div class="kg-left-panel"> <div class="history-btn-container"><button id="history-btn" class="secondary-btn">History</button><span id="history-ping" class="ping hidden">0</span></div> <button id="claim-reward-btn" class="reward-chest hidden">üéÅ</button> <div class="coin-display"> <h2 id="kg-coin-count">0</h2> <p id="kg-cps-count">0 coins/sec</p> </div> <div class="clicker-area"><button id="kg-clicker-btn">üëë</button></div> <div id="kg-player-stats"> <h4>Your Stats <button id="rank-privileges-btn" class="info-btn">‚ìò</button></h4> <p class="hidden"><strong>Title:</strong> <span id="kg-player-title"></span></p> <p><strong>Power:</strong> <span id="kg-player-power">0</span></p> <p><strong>Rank:</strong> <span id="kg-player-rank">Unranked</span></p> <p style="color: var(--brand-green);"><strong>Total Bonus:</strong> <span id="kg-player-total-bonus">x1.0</span></p> </div> <div class="shop-container"> <h4>Gem Shop (<span id="kg-gem-count">0</span>)</h4> <div id="kg-gem-shop"></div> </div> </div> <div class="kg-middle-panel"><div class="upgrades-container"><h4>Buildings</h4><div id="kg-upgrades-list"></div></div></div> <div class="kg-right-panel"><div class="army-container"><h4>Army</h4><div id="kg-army-list"></div></div><div class="defense-container"><h4>Defenses</h4><div id="kg-defenses-list"></div></div></div> <div class="kg-bottom-panel"> <button id="leaderboard-btn" class="secondary-btn">View Leaderboard</button> <div id="kg-buy-time-container" class="kg-buy-time-container"> <select id="kg-buy-time-select"><option value="1">1 Hour</option><option value="6">6 Hours</option><option value="12">12 Hours</option><option value="24">24 Hours</option></select> <button id="kg-buy-time-btn" class="secondary-btn">Buy Time</button><small id="kg-buy-time-cost-display">Cost: ...</small> </div> <div class="send-coins-container"><h4>Send Coins</h4><div class="user-select-wrapper"><input type="text" id="kg-recipient-search" placeholder="Player name..."><div id="kg-recipient-dropdown" class="user-dropdown-content"></div></div><input type="number" id="kg-send-amount" placeholder="Amount" min="1"><button id="kg-send-btn" class="secondary-btn">Send</button><small id="send-fee-info"></small></div> <div class="rebirth-section" style="width: 250px;"><h4>Rebirth Lvl: <span id="rebirth-level-display">0</span> <button id="rebirth-info-btn" class="info-btn">?</button></h4><div class="progress-bar-container"><div id="rebirth-progress-bar" class="progress-bar"><span id="rebirth-progress-text"></span></div></div><div id="rebirth-button-container" class="rebirth-info"></div></div> <div class="attack-container"><h4>Attack</h4><div class="user-select-wrapper"><input type="text" id="kg-attack-target-search" placeholder="Player name..."><div id="kg-attack-target-dropdown" class="user-dropdown-content"></div></div><button id="kg-attack-btn" class="secondary-btn-red">Attack</button></div> </div> </div>`; 
        if (currentUser?.user_status === 'Perm') document.getElementById('kg-buy-time-container')?.classList.add('hidden'); 
        document.getElementById('kg-clicker-btn').addEventListener('click', () => handleKingGameAction('click')); 
        const buyTimeSelect = document.getElementById('kg-buy-time-select'); const buyTimeCostDisplay = document.getElementById('kg-buy-time-cost-display'); 
        const updateCostDisplay = () => { if (!buyTimeSelect || !buyTimeCostDisplay) return; const h = parseInt(buyTimeSelect.value, 10); const purchaseCount = BigInt(kingGameState.time_purchase_count || 0); const costMultiplier = 100n ** purchaseCount; const c = (BASE_COST_PER_HOUR * BigInt(h)) * costMultiplier; buyTimeCostDisplay.textContent = `Cost: ${formatBigNumber(c)}`; if(document.getElementById('kg-buy-time-btn')) document.getElementById('kg-buy-time-btn').disabled = kingGameState.coins < c; }; 
        if(buyTimeSelect) { buyTimeSelect.addEventListener('change', updateCostDisplay); document.getElementById('kg-buy-time-btn').addEventListener('click', () => { const h = parseInt(buyTimeSelect.value, 10); const purchaseCount = BigInt(kingGameState.time_purchase_count || 0); const costMultiplier = 100n ** purchaseCount; const c = (BASE_COST_PER_HOUR * BigInt(h)) * costMultiplier; if (confirm(`Are you sure you want to spend ${formatBigNumber(c)} coins to add ${h} hour(s) to your key?`)) handleKingGameAction('buy_time', { hours: h }); }); } 
        let sendRecipientId = null; let attackTargetId = null; const setSendRecipient = (id) => { sendRecipientId = id; }; const setAttackTarget = (id) => { attackTargetId = id; };
        setupUserSearch('kg-recipient-search', 'kg-recipient-dropdown', setSendRecipient, user => `<span class="username">${user.discord_username}</span>`);
        setupUserSearch('kg-attack-target-search', 'kg-attack-target-dropdown', setAttackTarget, user => `<span class="username">${user.discord_username}</span><span class="power">‚ö° ${formatBigNumber(user.power)}</span>`);
        const sendAmountInput = document.getElementById('kg-send-amount'); const feeInfo = document.getElementById('send-fee-info'); if (sendAmountInput && feeInfo) { sendAmountInput.addEventListener('input', () => { const amount = BigInt(sendAmountInput.value || 0); const feePercent = kingGameState.userRoles.coins === 'King' ? 0 : 70; if (amount > 0) { const fee = amount * BigInt(feePercent) / 100n; const net = amount - fee; feeInfo.textContent = `Fee (${feePercent}%): ${formatBigNumber(fee)}. Recipient gets: ${formatBigNumber(net)}.`; } else { feeInfo.textContent = ''; } }); }
        document.getElementById('kg-send-btn').addEventListener('click', () => { const a = BigInt(document.getElementById('kg-send-amount').value || 0); if (sendRecipientId && a > 0) { const feePercent = kingGameState.userRoles.coins === 'King' ? 0 : 70; const fee = a * BigInt(feePercent) / 100n; const net = a - fee; if(confirm(`You are about to send ${formatBigNumber(a)} coins.\nA ${feePercent}% fee (${formatBigNumber(fee)}) will be applied.\nThe recipient will receive ${formatBigNumber(net)} coins.\n\nDo you want to proceed?`)) handleKingGameAction('send_coins', { recipientId: sendRecipientId, amount: a.toString() }); } else { alert("Please select a valid user and enter a positive amount."); } });
        document.getElementById('kg-attack-btn').addEventListener('click', () => { if (attackTargetId) handleKingGameAction('attack_player', { targetId: attackTargetId }); else alert("Please select a valid player to attack."); });
        const showPrivileges = (category) => {
            const modal = document.getElementById('privileges-modal'); const modalTitle = document.getElementById('privileges-title'); document.querySelectorAll('.privileges-content').forEach(el => el.classList.add('hidden'));
            if (kingGameState.title === 'Emperor') {
                modalTitle.textContent = 'Emperor Privileges'; const emperorContent = document.getElementById('privileges-content-emperor'); const emperorList = document.getElementById('emperor-privileges-list'); emperorList.innerHTML = ''; 
                for (const cat in kingGameState.userRoles) { const role = kingGameState.userRoles[cat]; const privilegeItemId = `privilege-${cat}-${role}`; const originalPrivilegeItem = document.getElementById(privilegeItemId); if (originalPrivilegeItem) { const clonedItem = originalPrivilegeItem.cloneNode(true); const categoryHeader = document.createElement('p'); const categoryName = cat.charAt(0).toUpperCase() + cat.slice(1); categoryHeader.innerHTML = `<strong>From ${categoryName} Ranking:</strong>`; categoryHeader.style.marginBottom = '5px'; categoryHeader.style.color = 'var(--header-primary)'; clonedItem.insertBefore(categoryHeader, clonedItem.firstChild); emperorList.appendChild(clonedItem); } } emperorContent.classList.remove('hidden');
            } else { modalTitle.textContent = 'Top 3 Rank Privileges'; document.getElementById(`privileges-content-${category}`).classList.remove('hidden'); }
            document.querySelectorAll('.privileges-list li').forEach(li => li.classList.remove('highlight')); for(const cat in kingGameState.userRoles) { const role = kingGameState.userRoles[cat]; const li = document.getElementById(`privilege-${cat}-${role}`); if (li) li.classList.add('highlight'); } modal.classList.remove('hidden');
        };
        document.getElementById('leaderboard-btn').addEventListener('click', renderLeaderboardModal); 
        document.getElementById('leaderboard-privileges-btn').addEventListener('click', () => { const activeSort = document.querySelector('#leaderboard-controls .active').dataset.sort || 'power'; showPrivileges(activeSort); });
        document.getElementById('history-btn').addEventListener('click', () => { renderHistoryModal(); handleKingGameAction('mark_history_read'); });
        document.getElementById('rank-privileges-btn').addEventListener('click', () => showPrivileges('power'));
        document.getElementById('claim-reward-btn').addEventListener('click', () => { if (currentUser.user_status === 'Perm') { openGiftingModal(); } else { if (confirm('Claim your daily rewards? The amount of time depends on all your leaderboard ranks.')) handleKingGameAction('claim_daily_reward'); } });
        document.getElementById('rebirth-info-btn').addEventListener('click', () => { const progress = kingGameState.rebirth_progress; if (!progress || kingGameState.prestige_level >= MAX_PRESTIGE_LEVEL) { alert("You have reached the maximum Rebirth level."); return; } if (progress.canRebirth) { alert("You are ready to Rebirth!"); return; } let message = `Rebirth Lvl ${kingGameState.prestige_level + 1} Requirements:\n- Have ${progress.requiredPercent}% of all buildings at Level ${progress.requiredLevel}.\n\nYour progress: ${progress.currentPercent}% complete.\n\nHere are some buildings you still need to level up:\n`; progress.missingBuildings.forEach(b => { message += `- ${b.name} (Currently Lvl ${b.current})\n`; }); alert(message); });
        if (kingGameInterval) clearInterval(kingGameInterval); 
        kingGameInterval = setInterval(() => { if (!document.getElementById('king-game-container') || !kingGameState.has_active_key) { if (kingGameInterval) clearInterval(kingGameInterval); return; } kingGameState.coins += kingGameState.cps; updateCostDisplay(); updateKingGameUI(); }, 1000); 
        handleKingGameAction('load'); 
    };
    const renderEarnTimePage = async () => { const container = document.getElementById('earn-time-content'); if (!container || !currentUser) return; container.innerHTML = '<p>Loading your empire...</p>'; try { await renderKingGame(); } catch (error) { container.innerHTML = `<p class="error-message">Could not load game data. Please try again later.</p>`; } };
    if (suggestionForm) suggestionForm.addEventListener('submit', async (e) => { e.preventDefault(); const suggestionTextarea = document.getElementById('suggestion-textarea'); const gameNameInput = document.getElementById('game-name-input'); const gameLinkInput = document.getElementById('game-link-input'); const suggestionStatus = document.getElementById('suggestion-status'); if (!suggestionTextarea || !suggestionStatus || !gameNameInput || !gameLinkInput) return; const suggestion = suggestionTextarea.value.trim(); const gameName = gameNameInput.value.trim(); const gameLink = gameLinkInput.value.trim(); if (gameName === '' || gameLink === '' || suggestion === '') { suggestionStatus.className = 'status-message error'; suggestionStatus.textContent = 'Please fill all fields.'; return; } const btn = e.target.querySelector('button'); btn.disabled = true; btn.textContent = 'Sending...'; suggestionStatus.textContent = ''; try { const response = await fetch('/api/send-suggestion', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ suggestion, gameName, gameLink }) }); const result = await response.json(); if (!response.ok) throw new Error(result.error); suggestionStatus.className = 'status-message success'; suggestionStatus.textContent = 'Suggestion sent!'; suggestionForm.reset(); } catch (error) { suggestionStatus.className = 'status-message error'; suggestionStatus.textContent = error.message || 'Failed to send.'; } finally { btn.disabled = false; btn.textContent = 'Send Suggestion'; } });
    if (removeExpiredBtn) removeExpiredBtn.addEventListener('click', handleRemoveAllExpired);
    navLinks.forEach(link=>{link.addEventListener("click",e=>{const pageId=e.target.dataset.page;pageId&&(e.preventDefault(),window.history.pushState({page:pageId},"",`/${"home"===pageId?"":pageId}`),switchPage(pageId))})}),manageKeysLink&&manageKeysLink.addEventListener("click",e=>{e.preventDefault(),window.history.pushState({page:"manage-keys"},"","/manage-keys"),switchPage("manage-keys"),dropdownMenu.classList.remove("show")}),userProfileToggle&&userProfileToggle.addEventListener("click",()=>dropdownMenu.classList.toggle("show")),window.addEventListener("click",e=>{userProfileToggle&&!userProfileToggle.contains(e.target)&&!dropdownMenu.contains(e.target)&&dropdownMenu.classList.remove("show")});
    const modals = document.querySelectorAll('.modal-overlay'); modals.forEach(modal => { const closeAction = () => { modal.classList.add('hidden'); if(modal.id === 'leaderboard-modal' && leaderboardInterval) { clearInterval(leaderboardInterval); leaderboardInterval = null; } }; modal.querySelector('.modal-close-btn').addEventListener('click', closeAction); modal.addEventListener('click', (e) => { if (e.target === modal) closeAction(); }); });
    setupMobileNav();
    checkUserStatus();
});
